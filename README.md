This project is a fullstack application simulating a virus spread among an animal population. 

In the backend I used Java and the Spring Framework, especially Spring Boot, Spring Data JPA with Hibernate and H2 Database, Spring Web and Spring Security. For the frontend I used JavaScript with React and CSS. 

The following image shows a snapshot of the running simulation in the browser:

![Simulation_2](https://github.com/PeterNiederwieser/SimulationVirusSpreadFullStackApplication/assets/112017284/3713f8f3-692d-4f79-a936-e72cef28f35c)

On the left side there is the map showing the region, where the animals live, and each animal is displayed as a coloured circle. The movement of the animals can be tracked on the screen during the simulation. The colour of an animal indicates its health or infection status (light blue ... healthy; yellow ... recovered and immune; red ... infected; violet ... severely ill).

There are three charts on the right side displaying important data of the virus spread. If the simulation is running, these charts get updated regularly within short time intervals.

The communication between frontend and backend is based on REST API, except for the exchange of simulation data, which is realized by using a WebSocket connection. 

The simulation data is computed in the backend and needs to be transferred to the frontend, where the data is consumed. When the simulation is running, hundreds of thousands of simulation data records are required within a short period of time, which makes a WebSocket connection for data transmission more suitable than the use of REST API. The transmission happens 'on-demand,' meaning that if there are too few data records in the frontend, a request is sent from the frontend to the backend via the WebSocket connection. In the backend, the next simulation steps are then calculated, and afterwards the newly computed simulation data records are bundled and sent to the frontend via the WebSocket connection.

Before the simulation can be started, the user needs to log in on the login page or register first, in case the user has not registered yet. During the login, a JWT token is generated in the backend and sent with the response to the frontend, from where the token is included in the header of all subsequent HTTP requests for authentication reasons. 

After successful login, the user is redirected to a page (see the following image below) with three input fields, where the user can set the name of the simulation, the number of animals and the number of initial infections. After pressing the submit button, this data is sent to the backend via an HTTP request and subsequently the necessary conditions for starting the simulation are created in the backend. 

![Auswahl](https://github.com/PeterNiederwieser/SimulationVirusSpreadFullStackApplication/assets/112017284/fcf8d2b1-986f-467f-a43d-424a4d1153f2)

Each simulation prepared in this manner is displayed in the browser as a card (see image above). The user has the option to change the respective parameters, to delete the prepared simulation or to start the simulation by applying the run button. When clicking on the run button, the WebSocket connection is established, the user is redirected to the simulation page (see first image above) and the simulation is graphically displayed in the browser. 

Throughout many parts of the code, I placed emphasis on certain design principles, such as the SOLID principles or SLAP (Single Level of Abstraction), as well as Clean Code rules. I am aware that there is still much room for improvement, and therefore, I am very excited to seize the opportunity to actually get better with each new project!

All pictures that I used in the frontend are from pexels.com and the original map image was generated by DALL.E. 
